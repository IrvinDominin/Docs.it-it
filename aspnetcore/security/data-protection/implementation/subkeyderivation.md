---
title: Derivazione della sottochiave e crittografia autenticata in ASP.NET Core
author: rick-anderson
description: Informazioni sui dettagli di implementazione della protezione dei dati di ASP.NET Core sottochiave derivazione e autenticato crittografia.
ms.author: riande
ms.date: 10/14/2016
uid: security/data-protection/implementation/subkeyderivation
ms.openlocfilehash: 37e7b01700e8a6b755b5ed16a9d7d75a9eeb970e
ms.sourcegitcommit: a1afd04758e663d7062a5bfa8a0d4dca38f42afc
ms.translationtype: MT
ms.contentlocale: it-IT
ms.lasthandoff: 06/20/2018
ms.locfileid: "36275723"
---
# <a name="subkey-derivation-and-authenticated-encryption-in-aspnet-core"></a><span data-ttu-id="bdf26-103">Derivazione della sottochiave e crittografia autenticata in ASP.NET Core</span><span class="sxs-lookup"><span data-stu-id="bdf26-103">Subkey derivation and authenticated encryption in ASP.NET Core</span></span>

<a name="data-protection-implementation-subkey-derivation"></a>

<span data-ttu-id="bdf26-104">La maggior parte delle chiavi nell'anello chiave conterrà una forma di entropia e disporrà di informazioni algoritmiche indicante "crittografia in modalità CBC + convalida HMAC" o "crittografia GCM + convalida".</span><span class="sxs-lookup"><span data-stu-id="bdf26-104">Most keys in the key ring will contain some form of entropy and will have algorithmic information stating "CBC-mode encryption + HMAC validation" or "GCM encryption + validation".</span></span> <span data-ttu-id="bdf26-105">In questi casi, l'entropia incorporato noti come il materiale della chiave master (o KM) per la chiave e si esegue una funzione di derivazione della chiave per derivare le chiavi che verranno utilizzate per le operazioni di crittografia effettive.</span><span class="sxs-lookup"><span data-stu-id="bdf26-105">In these cases, we refer to the embedded entropy as the master keying material (or KM) for this key, and we perform a key derivation function to derive the keys that will be used for the actual cryptographic operations.</span></span>

> [!NOTE]
> <span data-ttu-id="bdf26-106">Le chiavi sono classi astratte e un'implementazione personalizzata potrebbe non funzionare come indicato di seguito.</span><span class="sxs-lookup"><span data-stu-id="bdf26-106">Keys are abstract, and a custom implementation might not behave as below.</span></span> <span data-ttu-id="bdf26-107">Se la chiave fornisce la propria implementazione di `IAuthenticatedEncryptor` invece di usare uno dei nostri factory incorporate, il meccanismo descritto in questa sezione non è più valido.</span><span class="sxs-lookup"><span data-stu-id="bdf26-107">If the key provides its own implementation of `IAuthenticatedEncryptor` rather than using one of our built-in factories, the mechanism described in this section no longer applies.</span></span>

<a name="data-protection-implementation-subkey-derivation-aad"></a>

## <a name="additional-authenticated-data-and-subkey-derivation"></a><span data-ttu-id="bdf26-108">Dati di autenticazione aggiuntivi e la derivazione della sottochiave</span><span class="sxs-lookup"><span data-stu-id="bdf26-108">Additional authenticated data and subkey derivation</span></span>

<span data-ttu-id="bdf26-109">Il `IAuthenticatedEncryptor` interfaccia funge da interfaccia principale per tutte le operazioni di crittografia autenticata.</span><span class="sxs-lookup"><span data-stu-id="bdf26-109">The `IAuthenticatedEncryptor` interface serves as the core interface for all authenticated encryption operations.</span></span> <span data-ttu-id="bdf26-110">Il relativo `Encrypt` metodo accetta due buffer: testo non crittografato e additionalAuthenticatedData (AAD).</span><span class="sxs-lookup"><span data-stu-id="bdf26-110">Its `Encrypt` method takes two buffers: plaintext and additionalAuthenticatedData (AAD).</span></span> <span data-ttu-id="bdf26-111">Il flusso di contenuto di testo normale invariata la chiamata a `IDataProtector.Protect`, ma AAD è generato dal sistema ed è costituito da tre componenti:</span><span class="sxs-lookup"><span data-stu-id="bdf26-111">The plaintext contents flow unchanged the call to `IDataProtector.Protect`, but the AAD is generated by the system and consists of three components:</span></span>

1. <span data-ttu-id="bdf26-112">L'intestazione magic 32-bit 09 F0 C9 F0 che identifica questa versione del sistema di protezione dati.</span><span class="sxs-lookup"><span data-stu-id="bdf26-112">The 32-bit magic header 09 F0 C9 F0 that identifies this version of the data protection system.</span></span>

2. <span data-ttu-id="bdf26-113">Id della chiave a 128 bit.</span><span class="sxs-lookup"><span data-stu-id="bdf26-113">The 128-bit key id.</span></span>

3. <span data-ttu-id="bdf26-114">Stringa a lunghezza variabile formata dalla catena di scopo che ha creato il `IDataProtector` che esegue questa operazione.</span><span class="sxs-lookup"><span data-stu-id="bdf26-114">A variable-length string formed from the purpose chain that created the `IDataProtector` that's performing this operation.</span></span>

<span data-ttu-id="bdf26-115">Poiché Azure ad è univoco per la tupla di tutti e tre i componenti, è possibile usarlo per derivare nuove chiavi KM anziché KM stesso in tutti gli operazioni di crittografia.</span><span class="sxs-lookup"><span data-stu-id="bdf26-115">Because the AAD is unique for the tuple of all three components, we can use it to derive new keys from KM instead of using KM itself in all of our cryptographic operations.</span></span> <span data-ttu-id="bdf26-116">Per ogni chiamata a `IAuthenticatedEncryptor.Encrypt`, avviene il processo di derivazione della chiave seguente:</span><span class="sxs-lookup"><span data-stu-id="bdf26-116">For every call to `IAuthenticatedEncryptor.Encrypt`, the following key derivation process takes place:</span></span>

<span data-ttu-id="bdf26-117">(K_E, K_H) = SP800_108_CTR_HMACSHA512 (contextHeader K_M, AAD, | | keyModifier)</span><span class="sxs-lookup"><span data-stu-id="bdf26-117">( K_E, K_H ) = SP800_108_CTR_HMACSHA512(K_M, AAD, contextHeader || keyModifier)</span></span>

<span data-ttu-id="bdf26-118">In questo caso, stiamo chiamando l'utilizzo di SP800-108 NIST in modalità di contatore (vedere [NIST SP800-108](http://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-108.pdf), sec. 5.1) con i parametri seguenti:</span><span class="sxs-lookup"><span data-stu-id="bdf26-118">Here, we're calling the NIST SP800-108 KDF in Counter Mode (see [NIST SP800-108](http://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-108.pdf), Sec. 5.1) with the following parameters:</span></span>

* <span data-ttu-id="bdf26-119">Chiave di derivazione della chiave (KDK) = K_M</span><span class="sxs-lookup"><span data-stu-id="bdf26-119">Key derivation key (KDK) = K_M</span></span>

* <span data-ttu-id="bdf26-120">PRF = HMACSHA512</span><span class="sxs-lookup"><span data-stu-id="bdf26-120">PRF = HMACSHA512</span></span>

* <span data-ttu-id="bdf26-121">etichetta = additionalAuthenticatedData</span><span class="sxs-lookup"><span data-stu-id="bdf26-121">label = additionalAuthenticatedData</span></span>

* <span data-ttu-id="bdf26-122">contesto = contextHeader | | keyModifier</span><span class="sxs-lookup"><span data-stu-id="bdf26-122">context = contextHeader || keyModifier</span></span>

<span data-ttu-id="bdf26-123">L'intestazione del contesto è di lunghezza variabile e funge essenzialmente da un'identificazione personale degli algoritmi per il quale si sta derivazione K_E e K_H.</span><span class="sxs-lookup"><span data-stu-id="bdf26-123">The context header is of variable length and essentially serves as a thumbprint of the algorithms for which we're deriving K_E and K_H.</span></span> <span data-ttu-id="bdf26-124">Il modificatore di chiave è una stringa di 128 bit generata in modo casuale per ogni chiamata a `Encrypt` e serve a garantire con sovraccaricare probabilità che KE e KH siano univoci per questa operazione di crittografia di autenticazione specifici, anche se tutti gli altri input per l'utilizzo è costante.</span><span class="sxs-lookup"><span data-stu-id="bdf26-124">The key modifier is a 128-bit string randomly generated for each call to `Encrypt` and serves to ensure with overwhelming probability that KE and KH are unique for this specific authentication encryption operation, even if all other input to the KDF is constant.</span></span>

<span data-ttu-id="bdf26-125">Per la crittografia in modalità CBC + le operazioni di convalida HMAC, | K_E | è la lunghezza della chiave di crittografia simmetrico, e | K_H | è la dimensione del digest della routine HMAC.</span><span class="sxs-lookup"><span data-stu-id="bdf26-125">For CBC-mode encryption + HMAC validation operations, | K_E | is the length of the symmetric block cipher key, and | K_H | is the digest size of the HMAC routine.</span></span> <span data-ttu-id="bdf26-126">Per la crittografia GCM + operazioni di convalida, | K_H | = 0.</span><span class="sxs-lookup"><span data-stu-id="bdf26-126">For GCM encryption + validation operations, | K_H | = 0.</span></span>

## <a name="cbc-mode-encryption--hmac-validation"></a><span data-ttu-id="bdf26-127">La crittografia in modalità CBC + convalida HMAC</span><span class="sxs-lookup"><span data-stu-id="bdf26-127">CBC-mode encryption + HMAC validation</span></span>

<span data-ttu-id="bdf26-128">Una volta K_E viene generato tramite il meccanismo precedente, si genera un vettore di inizializzazione casuale ed eseguire l'algoritmo di crittografia simmetrica blocco per crittografia il testo non crittografato.</span><span class="sxs-lookup"><span data-stu-id="bdf26-128">Once K_E is generated via the above mechanism, we generate a random initialization vector and run the symmetric block cipher algorithm to encipher the plaintext.</span></span> <span data-ttu-id="bdf26-129">Il vettore di inizializzazione e il testo crittografato vengono quindi eseguite tramite la routine HMAC inizializzata con la chiave K_H per produrre il Mac.</span><span class="sxs-lookup"><span data-stu-id="bdf26-129">The initialization vector and ciphertext are then run through the HMAC routine initialized with the key K_H to produce the MAC.</span></span> <span data-ttu-id="bdf26-130">Questo processo e il valore restituito è rappresentato graficamente di seguito.</span><span class="sxs-lookup"><span data-stu-id="bdf26-130">This process and the return value is represented graphically below.</span></span>

![Restituzione e il processo in modalità CBC](subkeyderivation/_static/cbcprocess.png)

<span data-ttu-id="bdf26-132">*output:= keyModifier || iv || E_cbc (K_E,iv,data) || HMAC(K_H, iv || E_cbc (K_E,iv,data))*</span><span class="sxs-lookup"><span data-stu-id="bdf26-132">*output:= keyModifier || iv || E_cbc (K_E,iv,data) || HMAC(K_H, iv || E_cbc (K_E,iv,data))*</span></span>

> [!NOTE]
> <span data-ttu-id="bdf26-133">Il `IDataProtector.Protect` implementazione verrà [anteporre l'intestazione magic e l'id chiave](xref:security/data-protection/implementation/authenticated-encryption-details) all'output prima di restituirlo al chiamante.</span><span class="sxs-lookup"><span data-stu-id="bdf26-133">The `IDataProtector.Protect` implementation will [prepend the magic header and key id](xref:security/data-protection/implementation/authenticated-encryption-details) to output before returning it to the caller.</span></span> <span data-ttu-id="bdf26-134">Poiché l'intestazione magic e l'id chiave sono implicitamente in parte [AAD](xref:security/data-protection/implementation/subkeyderivation#data-protection-implementation-subkey-derivation-aad), e poiché il modificatore di chiave viene inserito come input per l'utilizzo, questo significa che ogni singolo byte del payload restituito finale è autenticato da Mac.</span><span class="sxs-lookup"><span data-stu-id="bdf26-134">Because the magic header and key id are implicitly part of [AAD](xref:security/data-protection/implementation/subkeyderivation#data-protection-implementation-subkey-derivation-aad), and because the key modifier is fed as input to the KDF, this means that every single byte of the final returned payload is authenticated by the MAC.</span></span>

## <a name="galoiscounter-mode-encryption--validation"></a><span data-ttu-id="bdf26-135">La crittografia della modalità Galois/contatore + convalida</span><span class="sxs-lookup"><span data-stu-id="bdf26-135">Galois/Counter Mode encryption + validation</span></span>

<span data-ttu-id="bdf26-136">Una volta K_E viene generato tramite il meccanismo precedente, si genera un parametro nonce 96 bit casuale ed eseguire l'algoritmo di crittografia simmetrica blocco per crittografia il testo non crittografato e generare il tag di autenticazione a 128 bit.</span><span class="sxs-lookup"><span data-stu-id="bdf26-136">Once K_E is generated via the above mechanism, we generate a random 96-bit nonce and run the symmetric block cipher algorithm to encipher the plaintext and produce the 128-bit authentication tag.</span></span>

![Restituzione e processo in modalità GCM](subkeyderivation/_static/galoisprocess.png)

<span data-ttu-id="bdf26-138">*output: = keyModifier | | parametro nonce | | E_gcm (K_E, nonce, i dati) | | authTag*</span><span class="sxs-lookup"><span data-stu-id="bdf26-138">*output := keyModifier || nonce || E_gcm (K_E,nonce,data) || authTag*</span></span>

> [!NOTE]
> <span data-ttu-id="bdf26-139">Anche se GCM supporta in modo nativo il concetto di AAD, ci stiamo ancora alimentazione AAD solo per l'utilizzo originale, scelta per passare una stringa vuota in GCM per il parametro AAD.</span><span class="sxs-lookup"><span data-stu-id="bdf26-139">Even though GCM natively supports the concept of AAD, we're still feeding AAD only to the original KDF, opting to pass an empty string into GCM for its AAD parameter.</span></span> <span data-ttu-id="bdf26-140">Il motivo è duplice.</span><span class="sxs-lookup"><span data-stu-id="bdf26-140">The reason for this is two-fold.</span></span> <span data-ttu-id="bdf26-141">Prima di tutto, [per supportare l'agilità](xref:security/data-protection/implementation/context-headers#data-protection-implementation-context-headers) non si desidera mai utilizzare K_M direttamente come chiave di crittografia.</span><span class="sxs-lookup"><span data-stu-id="bdf26-141">First, [to support agility](xref:security/data-protection/implementation/context-headers#data-protection-implementation-context-headers) we never want to use K_M directly as the encryption key.</span></span> <span data-ttu-id="bdf26-142">Inoltre, GCM impone requisiti di univocità molto rigidi per gli input.</span><span class="sxs-lookup"><span data-stu-id="bdf26-142">Additionally, GCM imposes very strict uniqueness requirements on its inputs.</span></span> <span data-ttu-id="bdf26-143">Imposta la probabilità che la routine di crittografia GCM viene sempre richiamato su due o più distinct di dati di input con lo stesso (nonce chiave) coppia non deve superare i 2 ^ 32.</span><span class="sxs-lookup"><span data-stu-id="bdf26-143">The probability that the GCM encryption routine is ever invoked on two or more distinct sets of input data with the same (key, nonce) pair must not exceed 2^32.</span></span> <span data-ttu-id="bdf26-144">Se è possibile risolvere K_E non è possibile eseguire più di 2 ^ 32 operazioni di crittografia, prima è eseguire afoul delle di 2 ^ limitare -32.</span><span class="sxs-lookup"><span data-stu-id="bdf26-144">If we fix K_E we cannot perform more than 2^32 encryption operations before we run afoul of the 2^-32 limit.</span></span> <span data-ttu-id="bdf26-145">Ciò potrebbe sembrare un numero molto elevato di operazioni, ma un server web a traffico elevato può passare attraverso le richieste di 4 miliardi in giorni semplice, comprese la durata normale per queste chiavi.</span><span class="sxs-lookup"><span data-stu-id="bdf26-145">This might seem like a very large number of operations, but a high-traffic web server can go through 4 billion requests in mere days, well within the normal lifetime for these keys.</span></span> <span data-ttu-id="bdf26-146">Per garantire la conformità di 2 ^ limite probabilità-32, si continuerà a utilizzare un modificatore di chiave a 128 bit e parametro nonce 96 bit, che estende radicalmente il conteggio delle operazioni utilizzabile per qualsiasi K_M specificato.</span><span class="sxs-lookup"><span data-stu-id="bdf26-146">To stay compliant of the 2^-32 probability limit, we continue to use a 128-bit key modifier and 96-bit nonce, which radically extends the usable operation count for any given K_M.</span></span> <span data-ttu-id="bdf26-147">Per semplicità di progettazione è condividere il percorso del codice di utilizzo tra le operazioni CBC e GCM e poiché Azure ad è già considerata nell'utilizzo non è necessario inoltrarla alla routine GCM.</span><span class="sxs-lookup"><span data-stu-id="bdf26-147">For simplicity of design we share the KDF code path between CBC and GCM operations, and since AAD is already considered in the KDF there's no need to forward it to the GCM routine.</span></span>
